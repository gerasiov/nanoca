#!/bin/sh
# nanoca -- Certificate Authority tool
#
# Copyright (C) 2008 Alexander GQ Gerasiov <gq@cs.msu.su>
#
# This program is free software.  It is distributed under the terms of
# the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

set -e

# Basic configs
BASE=""
COUNTRY="RU"
PROVINCE=""
CITY="Moscow"
ORGANIZATION=""


#TODO move this defines to config?
CA_DAYS=3653
CA_KEY="rsa:4096"
CERT_DAYS=1096
CERT_KEY="rsa:2048"
CERT_TYPE="server"
CONFIG_DIR="config"

# Read user's config
if [ -f "${HOME}/.nanoca" ];then
	. "${HOME}/.nanoca"
fi

export BASE COUNTRY PROVINCE CITY ORGANIZATION

COMMAND_NAME="nanoca"

CONFIG="${CONFIG_DIR}/openssl.cnf"

# Create certificate request.
create_req(){
	NAME="$1"
	CSR="${BASE}/req/${NAME}.csr"
	KEY="${BASE}/private/${NAME}.pem"

	if [ -e "$CSR" ];then
		echo "Aborted: certificate already exists."
		exit 1
	fi

	openssl req -config "$CONFIG" -new -newkey $CERT_KEY -keyout "$KEY" -out "$CSR" -nodes&&\
	echo "Done."||\
	echo "Failed."
	echo "$CERT_TYPE" > "${BASE}/req/${NAME}.type"
}

# Sign certificate request
sign_cert(){
	NAME="$1"

	CSR="${BASE}/req/${NAME}.csr"
	CERT="${BASE}/certs/${NAME}.pem"

	if [ ! -f "$CSR" ];then
		echo "Aborted: certificate request not found."
		exit 1
	fi

# todo: allow user to override this crap when signing?
	if [ -f "${BASE}/req/${NAME}.type" ];then
		CERT_TYPE="$(cat "${BASE}/req/${NAME}.type")"
	fi

	#  sign the certificate
	echo "CA signing: $CSR -> $CERT"

	openssl ca -config "$CONFIG" -extensions "$CERT_TYPE" -extfile "${CONFIG_DIR}/${CERT_TYPE}.cnf" -out "$CERT" -infiles "$CSR" ||{ echo "Error occured."; exit 1; }

	echo "CA verifying: $CERT <-> CA cert"
	openssl verify -CAfile "${BASE}/cacert.pem" "$CERT"
}

# Generate nanoca config
create_config(){
	echo  -e '\nBASE="'$(cd "$PARAMETER"&&pwd)'"' > ${HOME}/.nanoca
	echo "TODO: Parse the following line and push this into nanoca config."
	openssl x509 -subject -in ${BASE}/cacert.pem -noout
}

# Initialize openssl infrastructure
db_init(){
	if [ -e "$BASE" ];then
		echo "Aborted: directory allready exists."
		exit 1
	fi

	mkdir -p "$BASE"
	mkdir "${BASE}/req" "${BASE}/certs" "${BASE}/newcerts" "${BASE}/private"
	chmod 700 "${BASE}/private"

	touch "${BASE}/index.txt" "${BASE}/index.txt.attr"
	echo "00" > "${BASE}/serial"
}

# Create certificate authority
create_ca(){
	openssl req -new -newkey $CA_KEY -x509 -extensions v3_ca -keyout "${BASE}/private/cakey.pem" -out "${BASE}/cacert.pem" -days $CA_DAYS -config "$CONFIG"
}

#FIXME: add --brief support, and make list_ to use show_

# Print certificate in plain text
show_cert(){
	openssl x509 -in "${BASE}/certs/$1" -text
}

show_req(){
	openssl req -in "${BASE}/req/$1" -text
}

list_certs(){
	for FILE in "${BASE}/certs/"*.pem; do
		test -f "$FILE"||break
		test -s "$FILE"||continue

		NAME="${FILE#${BASE}/certs/}"
		NAME="${NAME%.pem}"
		SUBJECT="$(openssl x509 -in "$FILE" -subject -noout)"
#FIXME: type may differ from one, specified in request :( or not?
		TYPE="$(cat "${BASE}/req/${NAME}.type")"

		echo -e "\t$NAME\t$TYPE\t${SUBJECT#subject=}"
	done	
}

list_reqs(){
	for FILE in "${BASE}/req/"*.csr; do
		test -f "$FILE"||break
		test -s "$FILE"||continue

		NAME="${FILE#${BASE}/req/}"
		NAME="${NAME%.csr}"
		SUBJECT="$(openssl req -in "$FILE" -subject -noout)"
		TYPE="$(cat "${BASE}/req/${NAME}.type")"

		echo -e "\t$NAME\t$TYPE\t${SUBJECT#subject=}"
	done
}

#Remove request
rm_req(){
	echo "I'm not implemented yet."
	#Do some checks..
}

search(){
	 list_reqs | grep --label=req --null --with-filename --extended-regexp -- "$PARAMETER"
	 list_certs | grep --label=cert --null --with-filename --extended-regexp -- "$PARAMETER"
}

usage(){
	echo "$COMMAND_NAME operation [parameter]" >&2
	echo "Operations could be:"
	echo "init <path>"
	echo "create [--type <type>] <cert-name>"
	echo "request <cert-name>"
	echo "sign [--type <type>] <cert-name>"
	echo "show-cert [--brief] <name>"
	echo "show-req [--brief] <name>"
	echo "list-certs [--type <type>]"
	echo "list-reqs [--type <type>]"
	echo "search [--type <type>] <pattern>"
	echo "help"
}

parse_opt(){
	local TEMP="$(getopt -o t: --long type: -n "$COMMAND_NAME" -- "$@")"
	eval set -- "$TEMP"
	while true; do
		case "$1" in
			-t|--type)	CERT_TYPE="$2"; shift 2 ;;
			--) 		shift ; break ;;
			*) 		echo "Parse error!" ; exit 1 ;;
		esac
	done

	if [ $# -eq 0 -o $# -gt 2 ];then
		echo "Parse error!" ; usage; exit 1 ;
	fi

	COMMAND="$1"
	PARAMETER="$2"
}


parse_opt "$@"

case "$COMMAND" in
	init)		BASE="$PARAMETER"
			db_init
			create_ca
			create_config ;;
	create-ca)	create_ca ;;
	create)		create_req "$PARAMETER"&&sign_cert "$PARAMETER";;
	request)	create_req "$PARAMETER";;
	sign)		sign_cert "$PARAMETER";;
	show-cert)	show_cert "$PARAMETER";;
	show-req)	show_req "$PARAMETER";;
	list-certs)	list_certs;;
	list-reqs)	list_reqs;;
	rm-req)		rm-req "$PARAMETER";;
	search)		search "$PARAMETER";;
	help)		usage ;;
	*)		echo "Parse error!"; usage; exit 1 ;;
esac

